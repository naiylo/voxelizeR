% SPDX-FileCopyrightText: 2024 Helmholtz Centre Potsdam - GFZ German Research Centre for Geosciences
% SPDX-FileCopyrightText: 2024 Benjamin Brede
% SPDX-License-Identifier: GPL-3.0-or-later

% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/voxelize.R
\name{voxelize}
\alias{voxelize}
\title{Voxelize point cloud with ray-tracing}
\usage{
voxelize(
  rays,
  tiles,
  zrange,
  res,
  ac_single,
  voxel_mode,
  process_tiles_parallel,
  process_order_tiles,
  ...
)
}
\arguments{
\item{rays}{An object of class Rays (LAS with added trajectory)}

\item{tiles}{Sf Tiles representing the area to be processed}

\item{zrange}{Numeric boundaries for volume of interest in vertical dimension c(zmin, zmax)}

\item{res}{Numeric resolution as single value for all three dimensions or as c(x, y, z)}

\item{ac_single}{Numeric attenuation coefficient of single vegetation element https://www.mdpi.com/2072-4292/10/10/1580}

\item{voxel_mode}{"LAD" for Leaf Area Density estimation with various estimators, or "OCC" for occlusion mapping.}

\item{process_tiles_parallel}{Numbers of tiles to process in parallel (only on *nix systems with mclapply)}

\item{process_order_tiles}{Processing order of tiles. "random" for randomized processing (typically balances processing of full and empty voxels). "seq" for sequential processing}

\item{...}{Additional arguments passed to other methods or functions.}
}
\value{
Vox object.
}
\description{
This function voxelizes a point cloud by tracing rays through a specified volume of interest.
It is designed to process LiDAR data for applications such as Leaf Area Density (LAD) estimation or occlusion mapping.
}
\details{
The voxelize function takes a Rays object, representing a point cloud with an added trajectory,
and a set of tiles that define the area to be processed. It then performs ray-tracing within the specified
vertical boundaries (zrange) and at a given resolution (res). The function supports parallel processing
of tiles and allows for different processing orders to optimize performance.
}
\examples{
# Load required packages
library(lidR)
library(pracma)
library(dplyr)
library(data.table)
library(sf)

# Read in LAS data
data_file <- system.file("extdata", "H7_LS_F2_H20_200901-120129.laz", package = "voxelizer")
las <- readLAS(data_file)

# Ensure the CRS of the LAS object
epsg(las) <- 32631

# Create a trajectory for the LAS object
traj_file <- system.file("extdata", "H7_LS_F2_H20_200901-120129.traj", package = "voxelizer")
colnames <- c('gpstime', 'roll', 'pitch', 'yaw', 'Xorigin', 'Yorigin', 'Zorigin')
traj <- fread(traj_file, col.names = colnames) \%>\%
  select(gpstime, Xorigin, Yorigin, Zorigin) \%>\%
  rename(Xtraj = Xorigin,
         Ytraj = Yorigin,
         Ztraj = Zorigin) \%>\%
  mutate(gpstime = as.numeric(gpstime),
         Xtraj = as.numeric(Xtraj),
         Ytraj = as.numeric(Ytraj),
         Ztraj = as.numeric(Ztraj))

# Create a subset of the LAS data
laz <- las[1:10,]

# Compute rays from LAS points and trajectory
rays <- las2rays(laz, traj)

# Prepare tiles
tiles <- prepare_tiles(c(xmin = 682130, ymin = 5763580, xmax = 682300, ymax = 5763680),
                       res = c(x = 1, y = 1),
                       tilesize = c(20, 20),
                       crs = 32631)

# Prepare aoi
aoi <- st_bbox(tiles) \%>\%
  as.numeric() \%>\%
  setNames(names(st_bbox(tiles)))

# Prepare zrange
zrange <- c(50, 55) \%>\%
  setNames(c("zmin", "zmax"))

# Prepare res
res <- c(x = 1, y = 1, z = 1)

# Use voxelize function
vox <- suppressWarnings(voxelize(
  rays = rays,
  tiles = tiles,
  zrange = zrange,
  res = res,
  ac_single = 0.001,
  voxel_mode = "OCC",
  process_tiles_parallel = 1,
  process_order_tiles = "random"
))

}
\author{
Benjamin Brede
}
