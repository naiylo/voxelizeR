# SPDX-FileCopyrightText: 2024 Helmholtz Centre Potsdam - GFZ German Research Centre for Geosciences
# SPDX-FileCopyrightText: 2024 Benjamin Brede
# SPDX-License-Identifier: GPL-3.0-or-later

#' An S4 class to represent LiDAR rays
#'
#' @importFrom utils getFromNamespace
#' @importFrom terra round
#' @importFrom lidR LASheader
#' @importFrom methods callNextMethod
#'
#' @author Benjamin Brede
#'
#' @description
#' Class Rays is the representation of a las/laz file according to the
#' \href{https://www.asprs.org/wp-content/uploads/2019/07/LAS_1_4_r15.pdf}{LAS file format specifications}. `Rays` inherit from `LAS` with additional attributes:
#' \itemize{
#' \item{`Xtraj`, `Ytraj`, `Ztraj` (numeric): coordinates of the point on the trajectory from where laser pulse was fired}
#' \item{`Xorigin`, `Yorigin`, `Zorigin` (numeric): coordinates of origin of this segment, e.g. when multi-return pulses are split, or pulses are clipped}
#' \item{`XYZisHit` (logical): if XYZ represents a true hit or virtual end point generated by clipping Rays}}
#'
#' @examples
#' # Load required packages
#' library(lidR)
#' library(pracma)
#' library(dplyr)
#' library(data.table)
#'
#' # Read in LAS data
#' data_file <- system.file("extdata", "H7_LS_F2_H20_200901-120129.laz", package = "voxelizer")
#' las <- readLAS(data_file)
#'
#' # Create a trajectory for the LAS object
#' traj_file <- system.file("extdata", "H7_LS_F2_H20_200901-120129.traj", package = "voxelizer")
#' colnames <- c('gpstime', 'roll', 'pitch', 'yaw', 'Xorigin', 'Yorigin', 'Zorigin')
#' traj <- fread(traj_file[1], col.names = colnames) %>%
#'   select(gpstime, Xorigin, Yorigin, Zorigin) %>%
#'   rename(Xtraj = Xorigin,
#'          Ytraj = Yorigin,
#'          Ztraj = Zorigin)
#'
#' # Create a subset of the LAS data
#' laz <- las[1:10]
#'
#' # Compute rays from LAS points and trajectory
#' rays_obj <- las2rays(laz, traj)
#'
#' # Checking additional attributes initialization
#' attributes <- names(rays_obj@data)
#' print(attributes)
#'
#' # Combining two Rays objects
#' rays_obj1 <- new("Rays")
#' rays_obj2 <- new("Rays")
#' combined_rays <- rbind(rays_obj1, rays_obj2)
#' print(combined_rays)
#'
#' # Validity check for a Rays object
#' is_valid <- validObject(rays_obj)
#'
#' # Handling an empty Rays object
#' empty_rays_obj <- new("Rays")
#' empty_rays_obj@data <- empty_rays_obj@data[0, ]
#' is_empty_valid <- validObject(empty_rays_obj)
#'
#' # Show method for a Rays object
#' show(rays_obj)
#'
#' @exportClass Rays

setClass(
  Class = "Rays",
  contains = "LAS",
  package = "voxelizer"
)

#' Initialize object ray
#'
#' @author Benjamin Brede
#'
#' @param .Object Object
#' @param ... Additional arguments passed to other methods or functions.
#'
#' @return a Ray object
#'
#' @export

setMethod("initialize", "Rays", function(.Object, ...) {
  # Call the initialize method for the LAS class
  .Object <- methods::callNextMethod()

  # Initialize additional attributes for Rays
  .Object@data$Xtraj <- numeric()
  .Object@data$Ytraj <- numeric()
  .Object@data$Ztraj <- numeric()
  .Object@data$Xorigin <- numeric()
  .Object@data$Yorigin <- numeric()
  .Object@data$Zorigin <- numeric()
  .Object@data$XYZisHit <- numeric()
  .Object@data$IsOccluded <- numeric()

  # Set the header information
  header <- lidR::LASheader()

  # Check if header initialization succeeds and matches the required fields
  if (!is(header, "LASheader")) {
    stop("Error initializing LAS header.")
  }

  header@PHB[["Global Encoding"]][["WKT"]] <- TRUE
  header@PHB[["Version Minor"]] <- 4L
  header@PHB[["Point Data Format ID"]] <- 6L

  # Assign the header to the .Object
  .Object@header <- header

  # Return the initialized Rays object
  return(.Object)
})

#' Check if Object is initialized accordingly and inherits from LAS-Class
#'
#' @name Check (Rays)
#'
#' @author Benjamin Brede
#'
#' @param .Object Object to check

setValidity("Rays", function(object) {

  dims <- c("X", "Y", "Z")
  # names of columns in pc necessary for processing
  ray_col <- c(paste0(dims, "traj"), paste0(dims, "origin"), "XYZisHit", "IsOccluded")

  # Check for missing columns in the Rays object
  missing_columns <- ray_col[sapply(ray_col, function(col) !col %in% names(object@data))]
  if (length(missing_columns) != 0) {
    return(paste("Rays object is missing columns:", paste(missing_columns, collapse = ', ')))
  }

  # Ensure that the object inherits from LAS
  if (!is(object, "LAS")) {
    return("The object does not inherit from LAS class.")
  }

  return(TRUE)

})

#' Show object Ray
#'
#' @param object Ray to show
#'
#' @note copied from lidR/print.R
#'
#' @export

setMethod("show", "Rays", function(object) {

  size <- format(las_size(object), units = "auto")

  if (nrow(object@data) == 0) {
    ext <- c(Inf, -Inf, Inf, -Inf)
    area <- 0
    npoints <- 0
    npulses <- 0
    dpts <- 0
    dpulse <- 0
  } else {
    ext <- st_bbox(object)
    area <- as.numeric(st_area(object))
    npoints <- nrow(object@data)
    npulses <- object@header[["Number of points by return"]][1]
    dpts <- if (area > 0) npoints / area else 0
    dpulse <- if (area > 0) npulses / area else 0
  }

  npoints.h <- npoints
  area.h <- area
  phb <- object@header@PHB
  major <- phb[["Version Major"]]
  minor <- phb[["Version Minor"]]
  version <- paste(major, minor, sep = ".")
  format <- phb[["Point Data Format ID"]]
  units <- st_crs(object)$units
  units <- if (is.null(units) || is.na(units)) "units" else units

  areaprefix <- ""
  pointprefix <- ""

  if (area > 1000*1000/2)
  {
    areaprefix <- if (length(units) == 0) "thousand " else "k"
    area.h     <- terra::round(area/(1000*1000), 2)
  } else if (npoints > 1000 & npoints < 1000^2)
  {
    pointprefix <- "thousand"
    npoints.h   <- terra::round(npoints/1000, 1)
  } else if (npoints >= 1000^2 & npoints < 1000^3)
  {
    pointprefix <- "million" #nocov
    npoints.h   <- terra::round(npoints/(1000^2), 2) #nocov
  } else if (npoints >= 1000^3)
  {
    pointprefix <- "billion" #nocov
    npoints.h   <- terra::round(npoints/(1000^3), 2) #nocov
  }

  cat("class        : ", class(object), " (LAS v", version, " format ", format, ")\n", sep = "")
  cat("memory       :", size, "\n")
  cat("extent       : ", ext[1], ", ", ext[3], ", ", ext[2], ", ", ext[4], " (xmin, xmax, ymin, ymax)\n", sep = "")
  cat("coord. ref.  :", st_crs(object)$Name, "\n")
  cat("area         : ", area.h, " ", areaprefix, units, "\u00B2\n", sep = "")
  cat("points       : ", npoints.h, " ", pointprefix, " points\n", sep = "")
  cat("density      : ", round(dpts, 2), " points/", units, "\u00B2\n", sep = "")
  if (dpulse > 0)
    cat("density      : ", round(dpulse, 2), " pulses/", units, "\u00B2\n", sep = "")
  cat("names        :", paste(names(object), collapse = ", "), "\n")

  return(invisible(object))

})

#' Combine Rays objects
#'
#' @name rbind.Rays
#'
#' @import dplyr
#' @import lidR
#' @importFrom utils getFromNamespace
#'
#' @param ... Additional arguments passed to other methods or functions.
#'
#' @author Benjamin Brede
#'
#' @export

rbind.Rays <- function(...) {

  rays <- utils::getFromNamespace("rbind.LAS", "lidR")(...)

  # Ensure that the objects being combined are valid Rays objects
  if (!inherits(rays, "LAS")) {
    stop("The combined object must inherit from LAS.")
  }

  class(rays) <- "Rays"

  return(rays)

}

