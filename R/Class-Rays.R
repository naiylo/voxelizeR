#' An S4 class to represent LiDAR rays
#'
#' @import lidR
#' @import data.table
#' @import methods
#' @import stats
#'
#' @author Benjamin Brede
#'
#' @description
#' Class Rays is the representation of a las/laz file according to the
#' \href{https://www.asprs.org/wp-content/uploads/2019/07/LAS_1_4_r15.pdf}{LAS file format specifications}. `Rays` inherit from `LAS` with additional attributes:
#' \itemize{
#' \item{`Xtraj`, `Ytraj`, `Ztraj` (numeric): coordinates of the point on the trajectory from where laser pulse was fired}
#' \item{`Xorigin`, `Yorigin`, `Zorigin` (numeric): coordinates of origin of this segment, e.g. when multi-return pulses are split, or pulses are clipped}
#' \item{`XYZisHit` (logical): if XYZ represents a true hit or virtual end point (generated by clipping pulses \link{clip_pulses})}
#' }
#'
#' @exportClass Rays

setClass(
  Class = "Rays",
  contains = "LAS",
  package = "voxelizer"
)

#  TODO maybe the changeup makes a problem
#' Initialize object ray
#'
#' @author Benjamin Brede
#'
#' @param .Object Object
#' @param ... Additional arguments passed to other methods or functions.
#'
#' @return a Ray object
#'
#' @export

setMethod("initialize", "Rays", function(.Object, ...) {
  # Call the initialize method for the LAS class
  .Object <- callNextMethod()

  # Initialize additional attributes for Rays
  .Object@data$Xtraj <- numeric()
  .Object@data$Ytraj <- numeric()
  .Object@data$Ztraj <- numeric()
  .Object@data$Xorigin <- numeric()
  .Object@data$Yorigin <- numeric()
  .Object@data$Zorigin <- numeric()
  .Object@data$XYZisHit <- logical() # Initialize as logical
  .Object@data$IsOccluded <- logical() # Initialize as logical

  # Set the header information
  header <- LASheader()
  header@PHB[["Global Encoding"]][["WKT"]] <- TRUE
  header@PHB[["Version Minor"]] <- 4L
  header@PHB[["Point Data Format ID"]] <- 6L

  # Assign the header to the .Object
  .Object@header <- header

  # Return the initialized Rays object
  return(.Object)
})

#' Check if Object inherits from LAS-class
#'
#' @param .Object Object to check
#'
#' @name Check <- TODO

setValidity("Rays", function(object) {

  dims <- c("X", "Y", "Z")
  # names of columns in pc necessary for processing
  ray_col <- c(paste0(dims, "traj"), paste0(dims, "origin"), "XYZisHit", "IsOccluded")

  missing_columns <- ray_col[sapply(ray_col, function(col) !col %in% names(object))]

  if (length(missing_columns) != 0) {
    paste('rays misses columns:', missing_columns, collapse = ',')
  } else if (!is(object, "LAS")) {
    "Object does not inherit from LAS-class"
  } else {
    "Object does inherit from LAS-class"
    TRUE
  }

})

#' Show object Ray
#'
#' @param object Ray to show
#'
#' @note copied from lidR/print.R
#'
#' @export

setMethod("show", "Rays", function(object) {

  size      <- format(las_size(object), units = "auto")
  area      <- as.numeric(st_area(object))
  area.h    <- area
  npoints   <- nrow(object@data)
  npulses   <- object@header[["Number of points by return"]][1]
  npoints.h <- npoints
  dpts      <- if (area > 0) npoints/area else 0
  dpulse    <- if (area > 0) npulses/area else 0
  ext       <- st_bbox(object)
  phb       <- object@header@PHB
  major     <- phb[["Version Major"]]
  minor     <- phb[["Version Minor"]]
  version   <- paste(major, minor, sep = ".")
  format    <- phb[["Point Data Format ID"]]
  units     <- st_crs(object)$units
  units     <- if (is.null(units) || is.na(units)) "units" else units

  areaprefix  <- ""
  pointprefix <- ""

  if (area > 1000*1000/2)
  {
    areaprefix <- if (length(units) == 0) "thousand " else "k"
    area.h     <- round(area/(1000*1000), 2)
  } else if (npoints > 1000 & npoints < 1000^2)
  {
    pointprefix <- "thousand"
    npoints.h   <- round(npoints/1000, 1)
  } else if (npoints >= 1000^2 & npoints < 1000^3)
  {
    pointprefix <- "million" #nocov
    npoints.h   <- round(npoints/(1000^2), 2) #nocov
  } else if (npoints >= 1000^3)
  {
    pointprefix <- "billion" #nocov
    npoints.h   <- round(npoints/(1000^3), 2) #nocov
  }

  cat("class        : ", class(object), " (LAS v", version, " format ", format, ")\n", sep = "")
  cat("memory       :", size, "\n")
  cat("extent       : ", ext[1], ", ", ext[3], ", ", ext[2], ", ", ext[4], " (xmin, xmax, ymin, ymax)\n", sep = "")
  cat("coord. ref.  :", st_crs(object)$Name, "\n")
  cat("area         : ", area.h, " ", areaprefix, units, "\u00B2\n", sep = "")
  cat("points       : ", npoints.h, " ", pointprefix, " points\n", sep = "")
  cat("density      : ", round(dpts, 2), " points/", units, "\u00B2\n", sep = "")
  if (dpulse > 0)
    cat("density      : ", round(dpulse, 2), " pulses/", units, "\u00B2\n", sep = "")
  cat("names        :", paste(names(object), collapse = ", "), "\n")

  return(invisible(object))

})

#' Combine Rays objects
#'
#' @import dplyr
#' @import lidR
#' @importFrom utils getFromNamespace
#'
#' @param ... Additional arguments passed to other methods or functions.
#'
#' @author Benjamin Brede
#'
#' @export

rbind.Rays <- function(...) {
  #TODO here was a change for CRAN find out if it courses any problems -> one solution completly copy the rbind method in this package
  rays <- getFromNamespace("rbind.LAS", "lidR")(...)
  class(rays) <- "Rays"

  return(rays)

}

